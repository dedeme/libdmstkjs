// Copyright 28-Oct-2019 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

300 : klen. =

( @+s
  this,klen. cryp,key
@-s) crypPass =>
/// s::tx -> s::code
///   tx  : Text to encrypt
///   ----
///   code: Encripted text

( @+isl:: FExpired =; appName =; dmCgi? =
  {
    "dmCgi?": dmCgi?
    "appName": appName
    "FExpired": FExpired
    "connectionId": ""
  } map,from
@-m) new =>
/// i::dmcgi?, s::appName, (@ -> @)::FExpired -> m::Client
///   dmCgi?  : If is 'true' server is accessed through 'dmcgi'.
///   appName : Used to customize LocalStore.
///   FExpired: Function to launch expired page.
///   --------
///   Client  : Map with reserved fields.

( @+m:: Cl =
  "Client_sessionId_" : Cl .appName : + store,take
  ()
  ( "0" b64,encode)
  wrap,option
@-s) sessionId. =>

( @+ms:: value =; Cl =
  "Client_sessionId_" Cl .appName + : value : store,put
@-) setSessionId. =>

( @+m:: Cl =
  "Client_key_" : Cl .appName : + store,take
  ()
  ( "0" b64,encode)
  wrap,option
@-s) key. =>

( @+ms:: value =; Cl =
  "Client_key_" Cl .appName + : value : store,put
@-) setKey. =>

( @+ms:: value =; Cl =
  "Client_user_" Cl .appName + : value : store,put
@-) setUser. =>

( @+msl:: # Fn# =; rq# =; Cl# = //  rq is in B64
  Cl# .dmCgi? ("cgi-bin/ccgi.sh") ("") elif
    Cl# .appName  ":" rq# + +
      Fn#
      com,localRq
@-) sendServer. =>

( @+m:: Cl =
  "Client_user_" : Cl .appName : + store,take
  ()
  ( "0" b64,encode)
  wrap,option
@-s) user =>
/// m::Cl -> s::Id
///   Cl: Client
///   --
///   Id: Identifier.

( @+ml:: # fn# =>; Cl# =
  Cl#
  dup this,sessionId. : sessionId# =

  sessionId#
    (
      ( rp# =
        (
          rp# sessionId# cryp,decryp js,ro : Jsrp# =
          Jsrp# .key js,rs : key# =

          key# "" : ==
          ( 0 fn#)
          (
            Jsrp# .connectionId js,rs : cId# =
            Cl# key# this,setKey.
            Cl# "connectionId" cId# map,put
            1 fn#
          )
          elif
        )
        ( E =
          "RAW SERVER RESPONSE:\n${rp#}\n"
            "CLIENT ERROR:\n${E exc,msg}\n" + sys,log
        )
        try
      )
      ( e =
        "CLIENT ERROR:\n${e}" sys,log
      )
      wrap,either
    ) this,sendServer.
@-) connect =>
/// m::Cl, (@i -> @)::fn => @
///   Cl: Client
///   fn: Callback that receives '1' or '0' acording as conncection was
///       successfuly or not.
///   ==

( @+mssil:: # fn# =>; expiration =; pass =; user# =; Cl# =
  Cl# .appName this,crypPass : key# =
  pass this,crypPass : p# =
  expiration ("1") ("0") elif : exp =

  Cl# : ":" "${user#}:${p#}:${exp}" key# cryp,cryp +
    (
      ( rp# =
        (
          rp# key# cryp,decryp js,ro : Jsrp# =
          Jsrp# .sessionId js,rs : sessionId# =
          sessionId# "" : ==
          ( 0 fn#)
          (
            Jsrp# .key js,rs : newKey# =
            Cl# newKey# this,setKey.
            Cl# sessionId# this,setSessionId.
            Cl# user# this,setUser.
            1 fn#
          )
          elif
        )
        ( E =
          "RAW SERVER RESPONSE:\n${rp#}\n"
            "CLIENT ERROR:\n${E exc,msg}\n" + sys,log
        )
        try
      )
      ( e =
        "CLIENT ERROR:\n${e}" sys,log
      )
      wrap,either
    ) this,sendServer.
@-) authentication =>
/// m::Cl, s::user, s::pass, i::expiration, (@i -> @)::fn => @
///   Cl        : Client.
///   user      : User identifier.
///   pass      : User password.
///   expiration: 1 means temporary connection and 0 permanent one.
///   fn        : Callback which receive:
///     0: If authentication failed.
///     1: If authentication succeeded.
///   ==========

( @+mmli:: # withConnectionId =; fn# =>; Rq =; Cl# =
  withConnectionId (Rq : "connectionId" : Cl# .connectionId js,ws : map,put) if

  Cl#
    dup this,sessionId. ":"
      Rq js,wo : Cl# this,key. : cryp,cryp + +
    (
      ( rp# =
        (
          rp# Cl# this,key. cryp,decryp js,ro Jsrp# =
          ( Jsrp# fn#)
          ( E =
            "RAW SERVER RESPONSE:\n${rp#}\n"
              "CLIENT ERROR:\n${E exc,msg}\n" + sys,log
          )
          try
        )
        ( E =
          (
            rp# "nosession" cryp,decryp js,ro Jsrp# =
            Jsrp# "expired" map,has? (Jsrp# .expired js,rb) (0) elif
            ( Cl# dup .FExpired run)
            ( E exc,msg fail)
            elif
          )
          ( E =
            "RAW SERVER RESPONSE:\n${rp#}\n"
              "CLIENT ERROR:\n${E exc,msg}\n" + sys,log
          )
          try
        )
        try
      )
      ( e =
        "CLIENT ERROR:\n${e}" sys,log
      )
      wrap,either
    ) this,sendServer.
@-) send. =>

( @+mml 0 this,send. @-)
rq =>
/// m::Cl, m::Rq, (@m -> @)::fn => @
/// Request without connection identifier.
///   Cl: Client
///   Rq: Request. It is a map of JSON.
///   fn: Callback which receive a map of JSON.
///   ==

( @+mml 1 this,send. @-)
send =>
/// m::Cl, m::Rq, (@m -> @)::fn => @
/// Request with connection identifier.
///   Cl: Client
///   Rq: Request. It is a map of JSON.
///   fn: Callback which receive a map of JSON.
///   ==
