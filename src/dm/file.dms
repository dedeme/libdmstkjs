// Copyright 13-Nov-2019 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

( @+<Element>
  (e "return e.files.length;") ffi,i
@-i) inputSize =>

( @+<Element>i
  (e ix "return e.files[0];", File) ffi,o
@-<File>) inputGet =>

( @+<File>
  (f "return f.lastModified;") ffi,f
@-f) lastModified =>

( @+<File>
  (f "return f.name;") ffi,s
@-s) name =>

( @+<File>
  (f "return f.size;") ffi,i
@-i) size =>

( @+<File>
  (f "return f.type;") ffi,s
@-s) type =>

( @+<File>ii::
  (f start end "return f.slice(start, end);", JsBlob) ffi,o
@-<JsBlob>) slice =>

( @+<File>lllli:: #
  step# =; FnFail =; fnEnd# =>; fnAppend# =>; fnStart =>; File# =
  step# wrap,ref : Counter# =;

  chan,new : Ch =
  ( null =
    ("return new FileReader();", FileReader) ffi,o : Fr# =

    Fr# FnFail ffi,fn (fr fn "fr.onerror = fn") ffi,v

    Fr#
    (
      Fr# (reader "return new Uint8Array(reader.result);", Blob) ffi,o : Bs =
      Bs blob,size
      (
        chan,new : Ch =
        ( null =
          Counter# >> : start =
          start step# + : end =
          Counter# end <<
          Fr# : File# start end this,slice
            (reader bl "reader.readAsArrayBuffer(bl);") ffi,v
        ) Ch chan,recv
        Ch Bs fnAppend#
      )
      ( fnEnd#)
      elif
    ) ffi,fn (fr fn "fr.onloadend = fn") ffi,v

    Fr# : File# 0 step# this,slice
      (reader bl "reader.readAsArrayBuffer(bl);") ffi,v
  ) Ch chan,recv

  Ch File# fnStart
@-) read =>
/// @<File>lllli -> @
///   File: Client file.
///   fnStart: Function '@<File>l -> @' ([Channel, File] -> []). Initializes
///     reading. At the end send "" through Channel.
///   fnAppend: Function '@l<Blob> -> @' ([Channel, Bytes] -> []). Send
///     Byte to server. At the end send "" through Channel.
///   fnEnd: Function '@ -> @'. Runs after all data is send.
///   fnFail: Funciton '@ -> @'. Runs if an error happens.
///   step: Number of bytes sent each time.
